#include <string.h>
#include <glisy/gl.h>
#include <glisy/uniform.h>

void
glisy_uniform_init(glisy_uniform *uniform,
                   const char *name,
                   GLuint type,
                   GLuint dimension) {
  if (!uniform) return;
  if (!name) return;
  uniform->name = strdup(name);
  uniform->location = 0;
  uniform->type = type;
  uniform->dimension = dimension;
  uniform->buffer = 0;
}

void
glisy_uniform_bind(glisy_uniform *uniform, glisy_program *program) {
  GLint location = 0;
  GLint pid;
  if (!uniform) return;
  if (!uniform->name) return;
  if (!uniform->buffer) return;

  if (!program || 0 == program->id) {
    if (uniform->location) {
      location = uniform->location;
    } else {
      glGetIntegerv(GL_CURRENT_PROGRAM, &pid);
      location = glGetUniformLocation(pid, uniform->name);
    }
  } else {
    location = glGetUniformLocation(program->id, uniform->name);
  }

  if (location < 0) {
    // @TODO(werle) - handle error
    if (location == GL_INVALID_VALUE) {
      printf("program is not a value generated by OpenGL\n");
    } else if (location == GL_INVALID_OPERATION) {
      printf("program is not a program object or has not been successfully linked\n");
    } else {
      // this is likely from a uniform not being used
      printf("Unknown uniform location error for program(%d)\n", program ? program->id : -1);
    }
    return;
  }

  uniform->location = location;
  GLuint type = uniform->type;

#define VEXTRACT(T, b) *((T *) b)
#define GL_UNIFORM(suffix, ...)  \
  if (program && program->id) { \
    glProgramUniform ## suffix (program->id, __VA_ARGS__); \
  } else { \
    glUniform ## suffix (__VA_ARGS__); \
  }

  if (type == GLISY_UNIFORM_DOUBLE ||
      type == GLISY_UNIFORM_FLOAT) {
    GL_UNIFORM(1f, location, VEXTRACT(GLfloat, uniform->buffer));
  } else if (type == GLISY_UNIFORM_BOOL ||
             type == GLISY_UNIFORM_INT) {
    GL_UNIFORM(1i, location, VEXTRACT(GLint, uniform->buffer));
  } else if (type == GLISY_UNIFORM_UINT) {
    GL_UNIFORM(1ui, location, VEXTRACT(GLuint, uniform->buffer));
  } else switch (uniform->dimension) {

    // vec4 mat4
    case 4:
      if (GLISY_UNIFORM_VECTOR == type) {
        GL_UNIFORM(4fv, location, 1, uniform->buffer);
      } else if (GLISY_UNIFORM_MATRIX == type) {
        GL_UNIFORM(Matrix4fv, location, 1, GL_FALSE, uniform->buffer);
      }
      break;

    // vec3 mat3
    case 3:
      if (GLISY_UNIFORM_VECTOR == type) {
        GL_UNIFORM(3fv, location, 1, uniform->buffer);
      } else if (GLISY_UNIFORM_MATRIX == type) {
        GL_UNIFORM(Matrix3fv, location, 1, GL_FALSE, uniform->buffer);
      }
      break;

    // vec2 mat2
    case 2:
      if (GLISY_UNIFORM_VECTOR == type) {
        GL_UNIFORM(2fv, location, 1, uniform->buffer);
      } else if (GLISY_UNIFORM_MATRIX == type) {
        GL_UNIFORM(Matrix2fv, location, 1, GL_FALSE, uniform->buffer);
      }
      break;

    // scalar
    case 1:
      GL_UNIFORM(1fv, location, 1, uniform->buffer);
      break;
  }

#undef GL_UNIFORM
#undef VEXTRACT
}

void
glisy_uniform_set(glisy_uniform *uniform, void *data, GLsizei size) {
  if (!uniform) return;
  if (!data) return;
  if (!size) return;
  uniform->buffer = data;
  uniform->size = size;
}
